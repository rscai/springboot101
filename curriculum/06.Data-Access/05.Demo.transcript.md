## Data Access Demo

### import dependency

首先，將 spring-boot-starter-data-jpa 加到 build.gradle 的 dependency 中，還有 H2。

### object relational mapping

然後，使用注解定義對象模型與關系式模型之間的映射。
@Entity 指明這個 Post 類是業務實體，@Table 定義對應的關系式表。
@Column 定義屬性與列的映射。@Column 可加到屬性上，也可加到getter 訪問器上。
通過 @Column 可以定義列的名穪、長度、可否為空。類型從屬性類型自動推斷出來。
@Id 用以定義唯一標識。對應到關系式模型中，就是主鍵。
對於唯一標識，是可以定義生成策略的。AUTO 策略就是由數據庫生成新的唯一標識。

對 Comment 類也一樣，定義 @Entity @Table @Id @Column
在對象模型中， post 是一個到 Post 對象的引用，且 Comment 對 Post 是多對一關系。所以，這里用 @ManyToOne 注解。對應到關系式模型中，其就是以外鍵實現的關系。這里用 @JoinColumn 來定義這個外鍵。

至此，對象模型到關系式模型之間的映射就定義完成了。

### define repository

接下來，我們定義相應的 Repository 。 Repository 的設計準則之一：一個 Repository 負責一個業務模型。所以，需要分別定義 PostRepository 和 CommentRepository。

PostRepository 從 JpaRepository 繼承。JpaRepository 是從 PagingAndSortingRepository 繼承而來，已經聲明了基本的增刪改查分頁方法，無需添加任何自定義查詢方法了。

CommentRepository 也從 JpaRepository 繼承。CommentRepository 除了基本的增刪改查方法外，還需要一個查詢某個 post 下所有 comment 的方法。所以添加一個 findByPost 方法。Spring Data 會自動為其生成實現。

### inject in controller

至此模型映射與 Repository 都已經定義完了。再接下來，就把定義的 Repository 注入 controller。

Controller 也採用相同的設計準則：一個Controller 負責一個業務模型。

使用 @Autowired 將 postRepository 注入 postController。將 create, getOne, getAll 方法轉接至對應的repository方法。

CommentRepository 也類似，使用 @Autowired 將 commentRepository 注入。將 create, getOne, getAll 方法轉接至對應的 repository 方法。

### Test

最後就是測試了。

創建一個 Junit TestCase PostControllerTest，使用注解 @RunWith 聲明使用Spring Runner來該測試用例。

在 Setup 階段構建 MockMvc 和其它輔助工具。
這里要強調一點，我們的測試用例是涉及外部數據訪問的。而自動化測試的準則之一，是環境無關。測試用例應能在任何環境任何時刻都能重復執行。所以這里我在Setup中使用Spring Test提供的 JdbcTestUtils 清空了表 POST 和 Comment 中的所有數據。 Setup 會在每個 @Test 之前被調用，在Setup中做前置數據清理可以避免測試用例中的多個測試互相干rao。

創建兩個 @Test

* testCreateAndGet
* testGetAll

testCreateAndGet 通過依次調用創建和獲取 REST API 來同時驗證創建和獲取實現的正確性。

testGetAll 先預置兩條 Post 記錄，再調用獲取所有 Post REST API 來驗證實現的正確性。

來運行一下。結果錯誤了。

查看 log 得知原因是 JDBC URL 沒有配置。

